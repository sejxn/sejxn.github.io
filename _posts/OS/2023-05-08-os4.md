---
title: "[OS] Part4. 메모리 관리"

categories:
  - OS

date: 2023-05-08
last_modified_at: 2023-05-11
---

## Part4 메모리 관리  
이번 파트에서는 프로세스를 메모리에 할당할 때 어떤 방법으로 할당하는지, 그리고 이로 인해 어떤 문제가 발생할 수 있는지 알아볼 것이다.  

## 연속 메모리 할당  
초기 메모리 할당 방법의 하나인 연속 메모리 할당은 전체 프로세스를 **연속적으로** 메모리에 할당하는 것이다. 프로세스가 실행되면 운영체제는 각 프로세스가 메모리를 얼마나 요구하는지, 또 가용 메모리 공간이 어디에 얼마나 있는지를 고려하여 할당하게 된다. 먼저 이 할당 방법에서 프로세스 보호는 어떻게 하는지 간단히 살펴보자.  

### 메모리 보호  
**상한 레지스터**와 **재배치 레지스터**에 의해 보호가 가능한데, 상한 레지스터는 논리 주소의 범위 값을 저장하고 재배치 레지스터는 가장 작은 물리 주소의 값을 저장한다. 이 두 레지스터는 프로세스마다 지정이 되고 논리 주소가 주어졌을 때 상한 레지스터와 재배치 레지스터를 이용해 이 프로세스 내의 주소인지 검사를 하여 간단히 보호할 수 있다. (MMU는 논리 주소를 상한 레지스터와 재배치 레지스터를 사용해 주소를 변환한다.)  
`- 논리 주소(논리 메모리)는 프로그래머 입장에서의 주소(메모리)이다. 물리 주소(물리 메모리)는 실제 물리적 메모리(RAM)의 주소(메모리)이다.`  
`- MMU(Memory Management Unit)는 논리 주소를 물리 주소로 변환시키는 하드웨어 장치이다.`  

### 메모리 할당  
연속 메모리 할당에서 연속적으로 메모리에 여러 프로세스가 할당되어 있다고 하자. 이 프로세스들 중 종료되는 프로세스는 자기가 차지하고 있던 메모리를 반환한다. 그렇게 되면 중간중간 빈 부분이 있는 형태가 된다. 이 빈 부분은 당연히 사용이 가능한 메모리 공간이고 **hole**이라고 부른다.(**가용할 수 있는 메모리 부분**을 hole이라고 부름) 다양한 크기의 hole이 여기저기 존재하게 되는데 새 프로세스에 메모리를 할당해 줄 때 hole 중 하나를 적절히 찾아내주어야 한다. 여기에 세 가지 방법이 있다.  
- 최초 적합: 검색을 메모리 첫 부분에서 시작하여 **첫 번째**로 찾아낸 프로세스를 할당할 수 있는 hole에 할당한다.  
- 최적 적합: 사용 가능한 hole 중에서 가장 **작은 것**을 택하여 할당한다.  
- 최악 적합: 사용 가능한 hole 중에서 가장 **큰 것**을 택하여 할당한다.  

일반적으로 최초 적합이 속도가 빠르다고 한다. 그런데 이렇게 할당했을 때 **단편화**라는 문제가 발생하게 된다.  
단편화 자체의 의미는 비어 있는 메모리 공간들은 충분히 크지만 그 메모리 공간을 사용할 수 없음을 말한다. 외부 단편화와 내부 단편화가 있는데 위의 연속 메모리 할당은 외부 단편화를 발생시킨다. 외부 단편화는 여러 사용 가능한 hole이 **너무 작은 조각**들로 있는 경우를 말한다. 이 사용 가능한 hole들을 전부 합치면 충분히 큰 메모리 공간이 되는데도 **흩어져** 있어(중간중간 말 그대로 구멍이 뽕뽕 나 있는 상태) 제대로 사용하지 못한다. 내부 단편화의 설명은 바로 다음에 나오는 페이지를 설명할 때 하겠다.  

## 페이징(Paging)  
논리 메모리는 **페이지라는 일정한 크기의 블록**으로 나누고, 물리 메모리는 **프레임이라는 페이지와 같은 크기의 블록**으로 나눈다. MMU는 페이지 테이블을 통해 논리 주소를 물리 주소를 변환하는데 논리 주소는 페이지 번호와 페이지 오프셋 두 개의 부분으로 나누어진다. 페이지 번호는 페이지 테이블에 접근할 때 사용되며 페이지 테이블은 각 페이지에 대응되는 프레임의 시작 주소를 저장하고 있다. 오프셋은 이 프레임 안에서의 위치이다.  
페이징은 **내부 단편화** 문제가 발생한다. 일정한 크기의 블록으로 나눌 때 사용되지 않는 부분이 있을 수 있다. 예를 들어 81KB의 프로세스를 4KB 페이지로 나누면 **마지막 페이지는 3KB가 남는다.** 이를 내부 단편화라고 한다.  

### TLB(Translation Look-Aside Buffer)  
페이지 테이블은 메인 메모리에 존재하게 된다. MMU가 주소를 변환할 때 메인 메모리에 접근을 두 번 하게 된다.(페이지 테이블에 접근하여[1번] 프레임을 알아내고 실제 물리 주소에 접근[2번]한다.)  
이렇게 페이지 테이블을 메인 메모리에 저장하게 되면 메모리 액세스 시간이 늘어날 수 있다. 그래서 MMU는 주소변환을 할 때 먼저 페이지 번호가 TLB에 있는지 확인한다. 없다면(TLB 미스) 바로 위에서 설명한 대로 메모리에 2번 접근하게 된다. 있다면 그걸 이용해 프레임을 얻어 물리 주소에 접근하게 된다.(1번 접근)  
`- TLB는 일종의 캐시다.`  

## 스와핑(Swapping)  
스와핑은 프로세스 또는 프로세스의 일부분을 실행 중에 *\*백업 저장 장치*로 내보내거나 반대로 저장 장치에서 메모리로 되돌릴 수 있는 기술이다. 이 스와핑을 이용해 모든 프로세스의 크기가 물리 메모리보다 큰 경우에도 동시에 실행하는 것이 가능하여 *\*다중 프로그래밍의 정도*를 증가시킨다.  
`* 백업 저장 장치는 일반적으로 보조 저장 장치이다.`  
`* 다중 프로그래밍의 정도는 메인 메모리에 프로세스가 얼마나 올라와 있는지를 말한다. 정도가 높다는 건 많이 올라올 수 있다는 뜻`  

### 표준 스와핑  
표준 스와핑은 메인 메모리와 백업 저장 장치 간에 **전체 프로세스**를 이동시킨다. 대기 또는 대부분의 시간을 대기 상태로 보내는 프로세스가 스와핑의 후보가 될 수 있다. 물론 이 방법은 프로세스 전체를 이동하는 데 걸리는 시간이 엄청나기 때문에 잘 사용되지 않는다.  

### 페이징에서의 스와핑  
페이징에서 스와핑은 **페이지 단위**로 이루어진다. 이 방법으로도 여전히 물리 메모리보다 큰 프로세스 크기를 가질 수 있다. 페이지를 메인 메모리에서 백업 저장 장치로 이동시키는 것을 페이지-아웃이라 하고 그 반대는 페이지-인이라 한다.  

위에서 설명한 페이징과 스와핑은 **가상 메모리**를 구현하기 위해 필수적인 개념들이다. 이제 이 가상 메모리가 무엇인지 알아볼 차례이다.  

## 가상 메모리(Virtual Memory)  
가상 메모리의 목표는 **다중 프로그래밍 정도를 높이는 데** 있다. 그러니까 작은 물리 메모리(메인 메모리)로도 여러 프로세스를 실행시킬 수 있다. 가상 메모리를 구현하기 위한 기술인 페이징에 대해 조금 더 알아보자.  

### 요구 페이징  
요구 페이징은 필요한 부분 즉, **필요한 페이지**만 메모리에 올리는 기법이다. 결과적으로 프로세스가 실행되는 동안 일부 페이지는 메인 메모리에 있고 다른 일부는 보조 저장 장치에 있다. 그래서 이 둘을 구별하기 위한 유효/무효 비트가 있다. 비트는 이 페이지가 메인 메모리에 있는지 보조 저장 장치에 있는지를 알려준다. 유효라면 메인 메모리에 있다는 의미이고, 무효라면 논리 주소 공간에 속하지 않거나 보조 저장 장치에 있다는 의미이다.  
프로세스가 메인 메모리에 올라와 있지 않은 페이지에 접근하려고 하면 비트에 무효로 설정되어 있으므로 ***\*페이지 폴트 트랩***을 발생시켜 처리하게 된다. 처리 과정을 거쳐 보조 저장 장치에 있는 페이지를 실제 물리 메모리의 프레임으로 읽어 들인다.  
극단적인 경우 메모리에 페이지가 하나도 올라와 있지 않을 수 있다. 이 경우를 **순수 요구 페이징**이라 한다. 즉, 어떤 페이지가 필요해지기 전에는 결코 그 페이지를 메모리로 적재하지 않는 방법이다.  
`* 페이지 폴트 트랩은 일종의 인터럽트이다.`  
`-페이지 폴트의 비율을 페이지 폴트율이라 한다.`  

이렇게 페이지가 필요해짐에 따라 메인 메모리에 올라와 있을 수 있고 보조 저장 장치에 있을 수도 있다. 그런데 요구 페이징에서는 프레임 할당과 페이지 교체 두 문제를 해결해야 한다. 즉, 처음 프로세스에 프레임을 얼마만큼 **할당**할 것인지 와 새로운 페이지를 메인 메모리에 올릴 때 메인 메모리가 꽉 차 페이지 중 어떤 페이지를 **교체**해야 할 것인가의 문제이다. 우선 페이지 교체 문제부터 살펴보자.  

## 페이지 교체 알고리즘  
페이지 교체 알고리즘은 메인 메모리의 어떤 페이지를 교체할 것인가의 문제이다. 가장 간단한 방법부터 살펴본다.  

### FIFO  
FIFO는 메인 메모리에 **먼저 올라온 순서대로** 교체하게 된다. 이 알고리즘은 이해도 쉽고 프로그램하기도 쉽지만 성능이 항상 좋은 건 아니다. 교체할 페이지가 바로 다음에 사용될 페이지 일 수도 있다.  

### 최적 페이지 교체  
최적 페이지 교체는 **앞으로 가장 오랫동안 사용되지 않을 페이지**를 교체한다. 이 알고리즘은 가장 낮은 페이지 폴트율을 가진다. 하지만 cpu 스케줄링 알고리즘에서의 SJF 알고리즘(최단 작업 우선 스케줄링)과 마찬가지로 **구현이 어렵다.** 프로세스가 앞으로 어떤 페이지를 참조할 것인지를 알아야 하기 때문이다. 그래서 이 알고리즘은 **비교 목적**으로 사용된다.  

### LRU 페이지 교체  
이 알고리즘은 **가장 오랜 기간 동안 사용되지 않은 페이지**를 교체한다. 페이지마다 마지막 사용 시간을 유지한다.**(하드웨어 지원)**  

### LRU 근사 페이지 교체  
LRU 근사 페이지 교체 알고리즘은 시간을 재는 게 아닌 참조 비트를 이용하여 **근사적으로** 오랜 기간 동안 사용되지 않은 페이지를 교체한다.  

## 프레임의 할당  
다음으로 프레임의 할당 문제를 살펴보자. 프로세스를 적재할 때 얼마만큼 프레임을 할당해야 하는가? 프로세스에 할당되는 프레임 수가 줄어들면 페이지 폴트율은 증가하고 프로세스 실행은 늦어지게 된다. 따라서 **최소한 몇 페이지**(프레임)는 할당해야만 한다. 아래 두 가지 할당 방법이 있을 수 있다.  
- 균등 할당: 균등 할당은 각 프로세스마다 **똑같이** 할당해 주는 방법이다.  
- 비례 할당: 비례 할당은 각 프로세스의 **크기를 고려**하여 할당해 주는 방법이다.  

프레임 할당의 또 다른 중요한 요소는 페이지 교체 알고리즘을 **어떤 범주를 대상으로 적용시킬 것인가**의 문제이다. 이에 두 가지 방법이 있다.  
- 전역 교체: 페이지 교체 알고리즘을 다른 프로세스에 속한 프레임을 포함한 **모든 프레임**을 대상으로 적용시킨다.  
- 지역 교체: 지역 교체는 각 프로세스가 **자기에게 할당된 프레임** 중에서만 알고리즘을 적용시킨다.  

일반적으로 전역 교체가 지역 교체 알고리즘보다 더 좋은 시스템 성능을 나타낸다고 한다.  

## 스래싱(Thrashing)  
스래싱은 어떤 프로세스가 실제 실행보다 더 많은 시간을 페이징에 사용하고 있을 때를 말하며 cpu 이용률이 낮아진다.  
이 스래싱을 개선하기 위해 **지역성 모델**을 사용할 수 있다. 지역성은 프로세스가 실행될 때에는 항상 어떤 특정한 지역에서만 메모리를 집중적으로 참조함을 말한다. 그러니까 이 지역성을 기반해서 **자주 참조될 것 같은 페이지**들을 메인 메모리에 올려놓을 수 있도록 해서 개선하는 것이다.  

## 요약  
+ 연속 메모리 할당은 메인 메모리에 연속적으로 프로세스를 할당하는 방법이다. 최초 적합, 최적 적합, 최악 적합에 따라 할당될 수 있다.  
+ 페이징은 메인 메모리(물리 메모리)를 프레임이라는 블록으로 나누고, 논리 메모리는 프레임과 같은 크기의 블록인 페이지로 나누어 할당하게 된다.  
+ 스와핑은 프로세스 또는 페이지를 메인 메모리와 백업 저장 장치(보조 저장 장치) 간에 스왑 하여 다중 프로그래밍 정도를 높인다.  
+ 가상 메모리 기술은 물리 메모리(메인 메모리)보다 큰 논리 메모리를 가지는 프로세스를 실행할 수 있게 한다.  
+ 요구 페이징은 프로세스 실행 중 페이지가 필요할 때만 페이지를 적재하는 기법이다.  
+ 메인 메모리에서 가용할 수 있는 공간이 부족하게 되면 페이지(프레임)를 교체하게 된다. 교체 알고리즘에는 FIFO, 최적 알고리즘, LRU 등이 있다.  
+ 스래싱은 어떤 프로세스가 실행보다 페이징 하는 데 더 많은 시간을 소비할 때를 말한다.  

어렵다... 개념이 어려운 게 아니라 뭘 어떤 식으로 설명해야 할지 어떤 걸 설명해야 할지 모르겠어서 어렵다. 어쨌든 다음 파트에서는 저장 장치에 관해 다룰 것이다.  

`* 이 글은 소위 공룡 책이라고 하는 Operating System Concepts 책을 보고 정리한 글입니다. 제 생각대로 적다 보니 틀린 부분이 있을 수 있는데 지적해 주시면 감사하겠습니다.`