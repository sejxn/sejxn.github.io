---
title: "[OS] Part2. 프로세스 관리"

categories:
  - OS

date: 2023-04-26
last_modified_at: 2023-04-26
---

## 운영체제 Part2 프로세스 관리  
운영체제에서 가장 중요한 부분 중 하나인 프로세스. 프로세스에 하드웨어 자원을 어떻게 할당할 것인가 하는 문제는 정말 중요하다. 이번 파트에서는 프로세스가 무엇인지, 스레드가 무엇인지, 프로세스에 cpu를 할당하는 방법은 무엇인지에 대해 알아볼 예정이다. 우선 프로세스가 무엇인지 알아보자.

## 프로세스가 무엇인가?  
프로세스는 간단히 말하면 실행 중인 프로그램이다. 프로그램은 디스크에 저장된 파일(실행 파일)과 같은 **수동적인** 존재라면 프로세스는 RAM에 적재되어 있는 **능동적인** 존재이다. 실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다.  
이 프로세스는 운영체제에서 **PCB**(Process Control Block)에 의해 표현된다. PCB는 프로세스에 대한 정보들을 담고 있는데 대표적으로 번호, 상태, 프로그램 카운터, cpu 레지스터 등이 있다.  
1. 번호: 식별자인 ID를 뜻한다.
2. 상태: 현재 프로세스 상태를 뜻한다.(보통 생성, 실행, 대기, 준비, 종료등의 상태가 있다.)
3. 프로그램 카운터: 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
cpu 레지스터: cpu의 레지스터값들을 가진다.  

여기서 등장하는 개념이 **문맥**(context)인데 후에 설명할 cpu 스케줄러에 의해서 cpu 코어를 다른 프로세스로 교환할 때 필요한 정보들을 얘기한다.(문맥은 cpu 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함하고 PCB에 저장됨.) 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업을 **문맥 교환**(context switch)이라고 한다.  
PCB를 요약하면 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소의 역할을 한다.  

다음으로 프로세스를 설명할 때 항상 따라나오는 스레드에 대해서 알아보자.  
`-프로세스가 실행되려면 cpu 자원이 필요하다.`  

## 스레드가 무엇인가?  
스레드는 **작업 흐름의 기본 단위**이다. 프로세스 내에 여러 작업 흐름이 있을 수 있는데 이들을 스레드로 처리할 수 있는 것이다. 예를 들어 워드프로세서에서 사용자 입력을 받는 작업 흐름과 맞춤법 검사를 하는 작업 흐름이 있다면 이들은 각각 스레드 단위로 생각하여 처리할 수 있다.  
`-프로세스는 항상 하나 이상의 스레드를 가진다.`  
`-스레드도 Control Block이 있다.(Thread Control Block, PCB와 비슷함.)`  

여기서 중요한 개념이 있다. 멀티태스킹과 멀티 프로세스, 멀티 스레드이다. 사실 이것들을 책에서 보든, 인터넷에 검색하여 보든 개인적으로 느끼기에 일관적이지 않다고 느꼈다.(물론 내가 이해를 잘못한 것일 수도 있다.) 그래서 내 멋대로 이해하려 한다..!  
+ 멀티태스킹(multi-tasking): 여러 태스크(작업)을 동시에 처리할 수 있다.  
+ 멀티프로세스(multi-process): 멀티태스킹에서 태스크의 단위가 프로세스라면 멀티프로세스이다.  
+ 멀티스레드(multi-thread): 멀티태스킹에서 태스크의 단위가 스레드라면 멀티스레드이다.  

멀티프로세스와 멀티스레드의 가장 큰 차이점은 메모리 이용에 있다. 각 프로세스는 **독립적인** 공간을 가지고 처리된다. 스레드는 프로세스 안의 여러 흐름이기 때문에 프로세스에 **포함**된다고 볼 수 있다. 때문에 한 프로세스의 스레드들은 독립된 공간을 가지면서 그 프로세스의 공간을 **공유**할 수도 있다. 따라서 멀티태스킹을 구현할 때 멀티프로세스 방식은 메모리 공간이 증가하지만 서로 독립된 공간을 가지고 있어서 ***\*영향을 받지 않는다.*** 멀티스레드 방식은 공간을 공유할 수 있어 메모리 공간이 적고 서로 영향을 받는다.(영향을 받기 때문에 **동기화**가 필요함. 다음 파트에서 설명한다.)  
`* 프로세스 끼리는 기본적으로 영향을 받지 않는다. 다만 IPC라는 통신 메커니즘을 통해 데이터를 주고 받을 수도 있다.`  

### 병행성과 병렬성의 의미  
병행 시스템은 여러 프로세스나 스레드를 빠르게 전환하며 실행되어 사용자로 하여금 동시에 **실행되는 것처럼** 보이게 한다. 병렬 시스템은 **실제로 동시에** 실행될 수 있다. 병행 시스템은 단일 코어와 다중 코어에서 구현될 수 있고, 병렬 시스템은 오직 다중 코어에서만 가능하다.  
### 사용자 스레드와 커널 스레드  
"스레드를 위한 지원은 사용자 스레드를 위해서는 사용자 수준에서, 커널 스레드를 위해서는 커널 수준에서 제공된다. 사용자 스레드는 커널 위에서 지원되며 커널의 지원 없이 관리되고, 커널 스레드는 운영체제에 의해 직접 지원되고 관리된다." 이 부분은 책에서 나온 내용을 그대로 적은 것이다. 그러니까 운영체제는 실질적으로 **커널 수준 스레드**를 스케줄하고 사용자 수준의 스레드는 관여하지 않는다. 커널 수준 스레드와 사용자 수준 스레드는 매핑이 된다.  

이제 이 스레드에 cpu를 할당할 때 어떻게 스케줄링을 하는지 알아보자.  

## cpu 스케줄링  
cpu 스케줄러는 **준비 상태**의 스레드들 중에서 현재 cpu를 할당할 스레드를 선택한다. 이 선택은 보통 운영체제에서 관리하는 큐(queue)에서 이루어진다.(스케줄링 큐라고 함.)  
cpu 스케줄링을 하는 방법은 크게 두 가지로 나뉜다. 하나는 **선점형**(preemptive)이고 다른 하나는 **비선점형**(nonpreemptive)이다. 선점형은 말 그대로 cpu가 한 스레드에 할당되었을 때 다른 스레드가 선점할 수 있다는 것이다. 비선점형은 그 스레드가 종료하든지, 대기 상태로 전환해 cpu를 방출할 때까지 점유한다.  

그럼 실제 스케줄링 알고리즘에는 어떤 것들이 있는지 살펴보자.  
`-최신 운영체제는 대부분 선점적이다.`  
`-책에서는 프로세스 단위로 설명한다. 하지만 실질적으로 운영체제는 커널 스레드를 스케줄링한다고 하니 필자는 스레드라고 하겠다.`  
`-여기서 스케줄링 알고리즘을 설명할 때는 처리 코어가 하나라고 가정한다. 그리고 비교 기준은 여러 가지가 있으나 여기서는 평균 대기 시간을 기준으로 한다. 대기 시간은 준비 큐에서 대기한 시간이다.`  

1. 선입 선처리 스케줄링(First-Come, First-Served Scheduling)  
말 그대로 먼저 cpu를 요청하는 스레드가 먼저 할당받는다. 평균 대기 시간은 일반적으로 최소가 아니다. 주요 특징 중 하나는 **convoy effect**인데 다른 스레드들이 긴 *\*cpu 버스트 시간*을 가진 하나의 스레드가 cpu를 양도하기를 기다리는 것을 말한다. 이렇게 되면 평균 대기 시간이 증가할 것이다.  
이 스케줄링 알고리즘은 **비선점형**이다. cpu가 할당되면 그 스레드가 종료하든지, I/O 처리를 요구하든지 하여 cpu를 방출할 때까지 cpu를 점유한다.  
`* cpu 버스트 시간은 스레드가 cpu를 사용한 시간을 의미한다.`

2. 최단 작업 우선 스케줄링(Shortest-Job-First Scheduling)  
이 알고리즘은 cpu 버스트 시간이 가장 적은 스레드부터 cpu를 할당받는다. 이렇게 되면 평균 대기 시간은 주어진 스레드 집합에 대해 **최소의 평균 대기 시간**을 가진다. 하지만 다음 cpu 버스트의 길이를 알 수는 없다. **예측**만 할 수 있을 뿐이다. 실제로 이전의 cpu 버스트들의 길이로 예측하여 계산한다.  
이 알고리즘은 선점형 또는 비선점형일 수 있다. 만약 한 스레드가 실행 중에 다른 스레드가 큐에 들어올 때 이 스레드의 cpu 버스트 시간이 현재 실행 중인 스레드의 남은 cpu 버스트 시간보다 짧다면 선점할 수 있다. 이렇게 되면 선점형이고, 그냥 그 cpu 버스트가 끝날 때까지 기다린다면 비선점형이다.  

3. 라운드 로빈 스케줄링(Round-Robin Scheduling)  
라운드 로빈 스케줄링 알고리즘은 각 스레드에 **시간 할당량**을 주어 그 시간 동안 cpu를 할당하게 한다. 스레드의 cpu 버스트 시간이 시간 할당량보다 작을 수 있는데 이 경우에는 자발적으로 cpu를 방출한다. cpu 버스트 시간이 할당량보다 긴 경우는 시간 할당량을 채운다면 타이머가 운영체제에 인터럽트를 발생시켜 스레드를 교체한다. 그렇기 때문에 선점형이라고 할 수 있다.  
라운드 로빈 스케줄링에서 주요한 이슈가 시간 할당량 문제인데, 시간 할당량이 너무 크면 그냥 FCFS(선입 선처리)스케줄링과 비슷하게 되며 너무 적다면 스레드 교체를 많이 하기 때문에 문맥 교환에 의한 오버헤드가 발생할 것이다. 따라서 **적절한 시간 할당량**을 설정해야 한다.  

4. 우선순위 스케줄링(Priority Scheduling)  
우선순위 스케줄링은 **가장 높은 우선순위**를 가진 스레드에 cpu를 할당한다. 위에 설명한 SJF(최단 작업 우선 스케줄링) 알고리즘이 우선순위 스케줄링의 특별한 경우이다. cpu 버스트 시간으로 우선순위를 결정한 것이다.  
우선순위 스케줄링도 SJF 스케줄링과 마찬가지로 선점형일 수 있고 비선점형일 수도 있다. 새로운 스레드가 준비 큐에 들어오면 이 스레드의 우선순위를 실행 중인 스레드의 우선순위와 비교한다. 선점형은 새로 들어온 스레드의 우선순위가 더 높다면 교체하고 비선점형은 단순히 큐에 넣을 뿐이다.  
이러한 우선순위 스케줄링의 주요 문제는 **기아**(starvation)이다. 실행 준비는 되어 있으나 우선순위가 낮아 cpu를 사용하지 못해 **무한히 대기**하는 경우를 말한다. 기아 문제는 **노화**(aging)로 해결할 수 있다. 대기하는 스레드들의 **우선순위를 점진적으로 증가**시키는 방법이다.  

5. 다단계 큐 스케줄링(Multilevel Queue Scheduling)  
이 스케줄링 알고리즘은 우선순위마다 별도의 큐를 갖는다. 큐들은 각각 다른 스케줄링 알고리즘이 있을 수 있다.  
큐 간 우선순위를 두기 때문에 우선순위가 낮아 cpu를 사용하지 못해 무한히 대기하는 **기아** 문제가 있을 수 있다.

6. 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)  
다단계 큐 스케줄링에서는 큐들 간 이동하지 않는다. 반면에 다단계 피드백 큐 스케줄링 같은 경우는 스레드가 큐들 사이를 이동한다.  
큐 간 이동이 가능하기 때문에 다단계 큐 스케줄링에서의 **기아 문제를 해결**할 수 있다.  
다단계 큐 스케줄링과 다단계 피드백 큐 스케줄링은 쓰이는 알고리즘이 큐마다 다를 수 있으므로 선점형일 수도 있고 비선점형일 수도 있다.  

## 요약  
+ 프로세스는 실행 중인 프로그램이다.
+ PCB는 프로세스를 표현하는 구조체이다.
+ 스레드는 작업 흐름의 기본 단위이다.
+ 병행성은 스레드 간 cpu 전환을 빠르게 하여 동시에 실행되는 환상을 제공하고 병렬성은 실제로 동시에 실행된다.
+ 선입 선처리 스케줄링은 큐에 먼저 들어온 순서대로 cpu를 할당한다.
+ 최단 작업 우선 스케줄링은 cpu 버스트 시간이 짧은 순서대로 할당한다. 실제로는 시간을 예측하여 스케줄 된다.
+ 라운드 로빈 스케줄링은 각 스레드마다 시간 할당량만큼 cpu를 할당하게 한다.
+ 우선순위 스케줄링은 각 스레드에 우선순위를 두어 우선순위가 가장 높은 스레드에 cpu를 할당한다.
+ 다단계 큐 스케줄링은 여러 큐로 분할하여 우선순위를 두고 각 큐마다 다른 스케줄링 알고리즘이 사용될 수 있다.
+ 다단계 피드백 큐는 큐 간 이동될 수 있다는 점을 제외하면 다단계 큐 스케줄링과 비슷하다.  

이렇게 간단하게 프로세스와 스레드, 그리고 cpu를 할당하는 방법을 살펴보았다. 사실 책에는 다른 많은 내용이 있지만 너무 깊이 들어가는 것 같아 제외했다. 다음 파트에서는 같은 공간을 공유하는 스레드 혹은 시스템 내에서 서로 영향을 주는 프로세스를 구현할 때 꼭 필요한 개념인 동기화에 대해 알아볼 것이다.  

`* 이 글은 소위 공룡 책이라고 하는 Operating System Concepts 책을 보고 정리한 글입니다. 제 생각대로 적다 보니 틀린 부분이 있을 수 있는데 지적해 주시면 감사하겠습니다.`