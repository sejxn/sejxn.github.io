---
title: "[OS] Part5. 저장 장치 관리"

categories:
  - OS

date: 2023-05-11
last_modified_at: 2023-05-11
---

## Part5 저장 장치 관리  
이번 파트에서는 저장 장치를 어떻게 관리하는지, 그리고 I/O 시스템에 대해 간략하게 알아본다.(저장 장치도 I/O 장치이다.)  

## HDD(Hard Disk Drives)  
우선 하드 디스크의 구조를 살펴본다. 하드 디스크는 CD처럼 생긴 원판이 여러 겹으로 쌓여있는 형태이다. 아래에는 하드 디스크를 구성하는 여러 요소들을 보여준다.
+ 플래터: 위에서 말한 CD처럼 생긴 원형 판이다.
+ 스핀들: 플래터의 원판 가운데를 중심으로 플래터를 회전시킨다.
+ 읽기-쓰기 헤드: 각 플래터 사이사이에 있는 플래터를 통해 읽고 쓸 수 있는 헤드이다.
+ 디스크 암: 모든 헤드를 한꺼번에 이동시키는 축이다.(디스크 암에 헤드가 달려있는 것이다.)
+ 트랙: 플래터에서 원형으로 되어 있는 논리적 단위.
+ 섹터: 트랙에서 일정한 크기의 논리적 단위.
+ 실린더: 여러 플래터에서 같은 트랙의 집합.  

이렇게 실제 헤드와 플래터를 이동하며 데이터를 읽고 쓰게 된다.  
이 하드 디스크를 속도의 측면으로 봤을 때 세 가지 요소가 있다. 첫 번째는 **전송 속도**이다. 전송 속도는 하드 디스크와 컴퓨터 간의 데이터 흐름의 속도이다. 두 번째는 **탐색 시간**인데 디스크 암(헤드)을 원하는 실린더로 이동하는 데 필요한 시간이다. 세 번째는 **회전 지연시간**으로 원하는 섹터를 헤드의 위치까지 회전(플래터 회전) 하는 데 걸리는 시간이다.  

## SSD(Solid-State Disk)  
ssd는 **플래시 메모리 기반 NVM**(Nonvolatile Memory)이다. 플래시 메모리는 하드 디스크와는 달리 전기 신호로 정보를 기억하는 반도체이다. 움직이는 부품이 없으므로 HDD보다 안정성이 높으며 탐색 시간이나 회전 지연시간이 없어 더 빠를 수 있다. 또 전력 소비량도 작다.  

## 디스크 스케줄링  
디스크 스케줄링은 디스크에 대한 여러 I/O 요청이 있을 때 어떤 요청부터 처리할 것인지에 대해 결정하는 알고리즘이다. 다중 프로그래밍 시스템에서는 많은 프로세스가 장치를 공유하므로 I/O 요청이 처리되는 순서를 관리하여 성능을 향상할 수 있다.(탐색 시간 즉, 헤드를 이동시키는 데 걸리는 시간을 줄인다. 또 회전 지연시간 즉, 플래터를 회전시키는 시간을 줄인다.)  

### 선입 선처리 스케줄링  
역시나 가장 간단한 스케줄링은 선입 선처리다. 물론 늘 그러다시피 일반적으로 빠른 서비스를 제공하지는 못한다.(헤드가 불필요하게 왔다 갔다 해야 할 수 있으므로)  

### SCAN 스케줄링  
스캔 스케줄링은 말 그대로 스캔하듯이 헤드를 이동시킨다. 디스크의 한 쪽 끝에서 다른 끝으로 이동하며 이동하는 중에 있는 요청을 모두 처리한다. 다른 한쪽 끝에 도달하면(그 뒤에 다른 요청이 없으면) 다시 역방향으로 이동하면서 이동하는 중에 있는 요청을 처리한다. 이렇게 끝에서 끝으로 **왔다 갔다 하며 요청을 처리**한다.  

### C-SCAN 스케줄링  
SCAN 스케줄링에 대해 다시 한번 생각해 보자. 한쪽 끝에서 다른 한쪽 끝으로 그리고 다시 역방향으로 그러니까 왔다 갔다 하면서 요청들을 처리한다. 그런데 한쪽 끝에 다다랐을 때 다시 역방향으로 이동하는 것이 과연 성능 향상에 도움이 될까? 헤드가 이동하면서 이동하는 중에 있는 요청을 처리하게 되는데 한쪽 끝에 다다랐으면 그 바로 이전 위치에는 요청이 거의 없을 것이다.(바로 방금 지나왔으므로) 대신 반대 방향에 많은 요청이 있을 수 있다.(그곳을 처리한지 가장 오래되었으므로)
그래서 C-SCAN 스케줄링은 한쪽 끝에서 시작하여 다른 한쪽 끝에 다다르면 다시 역방향으로 이동하는 게 아니라 **처음으로 돌아와서 요청 처리를 시작**한다.  

### NVM 스케줄링  
하드 디스크 스케줄링은 헤드 이동량을 최소화하는 데 주로 중점을 둔다. 반면 NVM은 전기식으로 처리가 되기 때문에(움직이는 부분이 없음) 스케줄링 알고리즘마다 성능이 거의 다르지 않아 간단한 선입 선처리 스케줄링을 사용한다.  

## 저장 장치 관리  
운영체제는 디스크를 논리적 단위로 나누어 관리한다. 이와 관련된 개념들을 살펴보자.
+ 파일 시스템: 파일 시스템은 운영체제에서 디스크를 **논리적으로 관리**하기 위한 하나의 시스템이다.  
+ 파티션: 디스크는 하나 이상의 파티션으로 나누어진다.(예: C 드라이브, D 드라이브 - 각각이 파티션임) 운영체제는 각 파티션을 **별도의 장치인 것처럼** 취급할 수 있다.  
+ 볼륨: 파일 시스템이 파티션에 배치될 때 볼륨이 생성된다. 파일 시스템이 적용되는 하나의 **공간**이라고 생각하면 된다.  

## RAID(Redundant Array of Independent Disk)  
RAID는 **성능**과 **신뢰성**을 향상시키기 위한 기술이다. 예를 들어 여러 디스크를 사용할 수 있고 병렬적으로 운영된다면 성능을 높일 수 있다. 그리고 디스크는 물리적인 것이기 때문에 수명이 다하거나 고장 날 경우를 대비해 중복 저장하여 데이터의 신뢰성을 높일 수 있다. 이러한 RAID 기술은 아래처럼 레벨에 따라 나뉜다.  
+ RAID 레벨 0: 레벨 0은 ***\*스트라이핑***하는 드라이브 구성을 말하며 어떠한 중복 저장도 하지 않는다.  
+ RAID 레벨 1: 레벨 1은 드라이브 *\*미러링*을 사용한다.  
+ RAID 레벨 4: *\*패리티 비트*를 이용하여 오류 복구가 가능하다. 패리티 비트는 원본이 저장된 디스크가 아닌 다른 한 디스크에 저장된다.  
+ RAID 레벨 5: 레벨 4와 비슷하다. 4에서는 패리티를 위한 디스크를 따로 썼지만 레벨 5에서는 각 디스크마다 **분산하여 패리티를 저장**한다. 하나의 드라이브 오류가 데이터 및 패리티의 분실을 동시에 야기하기 때문에 한 블록과 그 블록의 패리티를 같은 드라이브에 저장할 수는 없다.  
+ RAID 레벨 6: 레벨 5와 유사하다. 조금 다른 점은 여러 디스크 오류에 대비하기 위해 **추가의 중복 정보**를 저장한다.  

`* 스트라이핑은 여러 디스크에 데이터를 분산하여 저장하는 기술이다. 레벨 4와 5, 6도 이 기술을 사용한다.`  
`* 미러링은 각 디스크마다 동일한 데이터를 다른 디스크에 복제를 한다. 디스크가 4개라면 4개의 디스크가 더 필요한 셈이다.`  
`* 패리티 비트는 오류를 검사하기 위한 비트이다.`  

## 입출력 시스템  
컴퓨터는 크게 두 가지 주요 작업으로 이루어진다. 하나는 계산이고 하나는 입출력 작업이다. 운영체제 역할의 중요한 부분 중 하나는 입출력 장치를 관리하고 제어하는 일이다. 여기에서는 입출력 시스템에서의 주요 개념들만 살펴본다.  
+ 버스: 하드웨어들을 연결시키는 **통로**로, 어떻게 해야 메시지들을 주고받을 수 있는지를 정한 *\*프로토콜*까지를 포함한다.  
+ 메모리 맵드 입출력: 메모리 맵드 입출력은 장치 컨트롤러의 레지스터 주소와 메인 메모리 주소를 일대일로 사상한다. cpu는 메인 메모리에 접근하여 입출력 결과를 읽거나 쓰게 된다.  
+ 인터럽트: 인터럽트는 하드웨어와 소프트웨어의 **상호작용 방식**이다. cpu는 매 명령어를 끝내고 다음 명령어를 수행하기 전 인터럽트 요청 라인이라는 선을 검사한다. 입출력 하드웨어가 이 라인에 신호를 보내면 cpu가 검사하여 각종 레지스터 값과 상태 정보를 저장한 다음, 인터럽트 핸들러 루틴(운영체제 커널 내)으로 이동(jump) 한다. 인터럽트 핸들러는 인터럽트의 발생 원인을 조사하고 필요한 작업을 수행한 후 cpu를 인터럽트 전의 실행 상태로 되돌리기 위해 복귀 명령을 실행한다. 
요약하자면 장치 컨트롤러는 인터럽트 요청 라인으로 신호를 보냄으로써 인터럽트를 발생시키고 cpu는 이를 인지하여 인터럽트 핸들러를 수행한다. 수행이 끝나면 인터럽트 전 실행 상태로 복귀한다.  
+ DMA(Direct Memory Access): 직접 메모리 접근 즉, DMA는 말 그대로 하드웨어가 cpu의 개입 없이 메인 메모리에 **직접적으로 접근**한다. 이는 DMA 컨트롤러에 의해 이루어진다.  
+ 봉쇄형 입출력과 비봉쇄형 입출력(Blocking and Nonblocking I/O): 봉쇄형 입출력은 시스템 콜을 호출한 스레드를 대기 상태로 바꾼다. 입출력이 끝나면 다시 실행 큐로 되돌아와 자기 차례가 되면 실행을 재시작 한다.  
비봉쇄형 입출력은 대기시키지 않고 다른 작업을 수행할 수 있도록 한다.  

`* 프로토콜은 하나의 규약이라고 생각하면 된다.`  

## 요약  
+ 하드 디스크의 구조는 CD처럼 생긴 원판이 여러 겹으로 쌓여있는 형태이다. 디스크 암에 달려있는 헤드를 움직여 데이터를 읽고 쓴다.
+ 하드 디스크는 전송 속도, 탐색 시간, 회전 시간에 의해 성능이 측정된다.
+ 디스크 스케줄링 알고리즘에는 선입 선처리, SCAN, C-SCAN 등이 있다.
+ 저장 장치는 하나 이상의 공간으로 파티션 되고 각 파티션은 볼륨을 보유한다. 파일 시스템은 볼륨 안에 생성된다.
+ 디스크의 성능과 신뢰성 향상을 위해서 RAID라는 기술을 사용할 수 있다.
+ 입출력 장치를 관리하고 제어하는 일은 운영체제의 주요 역할이다.  

이렇게 part 5까지 왔다. 어째 뒤로 가면 갈수록 점점 내용이 적어지는 것 같다... 물론 다루지 않은 내용들 정말 많다. 근데 이해가 안 되거나 딱히 더 들어갈 필요가 없다고 생각되어 정리하지 않았다. 다음 파트는 파일 시스템에 대해 정리한다.  

`* 이 글은 소위 공룡 책이라고 하는 Operating System Concepts 책을 보고 정리한 글입니다. 제 생각대로 적다 보니 틀린 부분이 있을 수 있는데 지적해 주시면 감사하겠습니다.`