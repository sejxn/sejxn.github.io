---
title: "[OS] Part3. 동기화"

categories:
  - OS

date: 2023-05-03
last_modified_at: 2023-05-08
---

## Part3 동기화 
이번 파트에서는 동기화에 대한 개념과 방법들, 동기화에 의한 문제에 대해서 살펴본다. 먼저 동기화가 무엇인지, 동기화가 필요한 이유가 무엇인지에 대해 알아보자.  

## 동기화(Synchronization)  
동기화는 **데이터의 일관성**을 유지하기 위해서 사용된다. 예를 들어 멀티스레드 환경에서 한 프로세스 내의 여러 스레드들은 일부 공간을 **공유**한다. 이때 한 데이터에 여러 스레드가 접근을 하게 되면 일관성이 깨질 수 있다. 조금 더 자세히 들어가 보자.  
count라는 변수는 두 스레드가 공유하는 데이터라고 가정하자. 각 스레드는 count++과 count--의 코드를 포함하고 이를 병행하게 실행한다. count의 초기값이 5일 때, 이 두 명령어를 수행하고 나면 count 값은 4, 5, 혹은 6이 된다. 우리는 이 값이 5 이길 바라지만 멀티스레드 환경에서는 그렇지 않다.  
이 count++과 count--는 기계어로 번역되면 다음과 같아진다.  
```c++
// Thread1 count++
register1 = count
register1 = register1 + 1
count = register1

// Thread2 count--
register2 = count
register2 = register2 - 1
count = register2
```
여기서 count++과 count--를 병행하게 실행하는 것은 저 여섯 줄짜리 코드들을 뒤섞어 순차적으로 실행하는 것과 동등하다. 그중 하나는 다음과 같은 순서를 가질 수 있다.(이 세 줄짜리 코드 내에서는 순서가 지켜진다.)
```c++
register1 = count			// register1 == 5
register1 = register1 + 1 	// register1 == 6
register2 = count 		    // register2 == 5
register2 = register2 - 1 	// register2 == 4
count = register1 		    // count == 6
count = register2 		    // count == 4
```
우리는 count가 5 이길 바랐지만 4가 저장되면서 일관성이 깨지게 됐다. 이렇게 동시에 여러 스레드가 동일한 데이터를 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 **경쟁 조건**(race condition)이라고 한다. 우리는 위와 같은 경쟁 조건으로부터 보호하기 위해 count 변수에 한순간에 하나의 스레드만이 조작하도록 보장해야 한다. 그러니까 동기화가 필요하다는 말이다.  

### 임계 구역(Critical Section)  
위에서 설명한 동기화가 필요한 코드 부분을 **임계 구역**이라고 한다. 각 스레드는 자신의 임계 구역으로 진입하려면 허가를 요청해야 한다. 이 요청을 하는 부분이 진입 구역(entry section)이다. 임계 구역의 뒤는 퇴출 구역(exit section)이라고 했을 때 임계 구역은 보통 다음과 같은 형태를 가진다.  
```c++
while(true)
{
	entry section
		critical section
	exit section
		remainder section
}
```
이 임계 구역 문제는 다음의 세 가지 요구 조건을 충족하여 해결한다.  
1. 상호 배제(mutual exclusion): 오직 한 스레드만이 임계 구역에 진입할 수 있다.  
2. 진행(progress): 임계 구역에서 실행되는 스레드가 없을 때 임계 구역으로 진입하려고 하는 스레드들이 있다면 어느 스레드가 들어갈지 적절히 결정해 주어야 한다.  
3. 한정된 대기(bounded waiting): 임계 구역에 들어가기 위해 대기를 할 때 무한정 기다리게 해서는 안 된다.  

다음으로 실제 동기화하는 방법에 대해서 알아보자.  

## 뮤텍스 락(Mutex Locks)  
뮤텍스 락은 mutual exclusion lock의 준말로 임계 구역에 진입하기 전 반드시 **lock**을 획득해야 진입할 수 있다. 반대로 임계 구역에서 빠져나올 땐 lock을 반환하게 된다. 실제 코드의 형태는 다음과 같다.  
```c++
while(true)
{
	acquire lock
		critical section
	release lock
		remainder section
}
```
acquire lock 부분에서는 락을 요청하게 되고 만약 획득한다면 임계 구역으로 진입하게 된다. 임계 구역 실행이 끝나면 release lock 부분에서 lock을 반환하게 된다. 실제 lock은 불리언 변수로 락의 가용 여부를 표시한다. available이 lock의 가용 여부를 표시하는 변수라고 할 때 acquire와 release의 형태는 다음과 같을 수 있다.  
```c++
acquire()
{
	while(!available);
	available = false;
}

release()
{
	available = true;
}
```
이 방식의 단점은 **바쁜 대기**(busy waiting)이다. 이것은 **스핀락**(spinlock)이라고도 한다. 한 스레드가 임계 구역에 있는 동안 임계 구역에 들어가길 원하는 다른 스레드들은 acquire() 함수를 호출하는 반복문(while문)을 계속 실행해야 한다. 이 스핀락은 다른 스레드가 생산적으로 사용할 수 있는 cpu 주기를 낭비할 수 있다. 하지만 장점도 있다. 다른 스레드로 변경하지 않고 cpu를 계속 점유하기 때문에 **문맥 교환으로 인한 오버헤드가 일어나지 않는다.**  

## 세마포(Semaphores)  
세마포는 뮤텍스 락과 비슷하다. 뮤텍스 락과 다른 점은 불리언 변수 대신 **정수 변수**(S)를 사용한다.(이진 세마포라는 것도 있는데 0과 1의 값만 갖는다. mutex lock과 거의 비슷하다고 봐도 무방할듯하다.) 뮤텍스 락에서 acquire와 release랑 비슷하게 wait과 signal 함수를 구현할 수 있다. 바로 다음과 같다.  
```c++
// S는 동시에 자원을 사용할 수 있는 스레드의 개수로 초기화된다.
wait(S)
{
	while(S <= 0);
	S--;
}

signal(S)
{
	S++;
}
```
여기서 위의 mutex lock과 같이 바쁜 대기가 발생할 수 있다. 바쁜 대기로 구현하는 것 말고도 다른 방법으로 구현할 수 있다. 그것은 바로 **스레드의 상태를 변환**하는 것이다. 한 스레드가 wait 함수를 실행하고 S가 양수가 아니라면(위의 구현에서는 바쁜 대기) 자신을 대기 상태로 전환한다. 그 후 다른 스레드로 cpu는 넘어간다. 이렇게 일시 중지된 스레드는 다른 스레드가 signal() 연산을 실행하면 재시작되어야 하는데 이때 대기 상태에서 준비 상태로 변경한다. 이렇게 구현한 코드는 아래와 같다.  
```c++
typedef struct
{
	int value;
	struct thread *list;
} semaphore;

wait(semaphore *S)
{
	S->value--;
	if(S->value < 0)
	{
		add this thread to S->list;
		sleep();
	}
}

signal(semaphore *S)
{
	S->value++;
	if(S->value <= 0)
	{
		remove a thread T from S->list;
		wakeup(T);
	}
}
```
`- 여기에서 중요한 점은 위의 뮤텍스와 세마포의 함수들은 원자적으로 실행이 되어야 한다. 원자적의 의미는 그 실행이 끝날 때까지 어떤 방해도 받지 않고 완전히 수행될 수 있음을 의미한다. 원자적으로 실행하는 방법은 하드웨어적인 지원이 필요하다. 사실 원자적으로 실행하기 위해서 동기화를 하는 건데 그 방법들도 원자적으로 실행해야 한다니, 원자성을 보장하기 위해 원자성을 보장해야 하는 격이다. 그래서 필자는 뮤텍스나 세마포에 사용되는 원자성 보장을 그냥 공유 데이터 자체에 적용하면 안 될까라는 생각을 해보았다. chatGPT 님에게 물어보니... 원자적 실행은 하드웨어의 지원을 받아야 하고 이는 운영체제가 구현을 하기 때문에 프로그래머가 직접적으로 원자성을 구현하는 게 아니고 운영체제가 제공하는 동기화 도구를 통해 원자성을 구현하는 것 같다...!`  

## 모니터(Monitors)  
이렇게 뮤텍스와 세마포를 간단하게 구현해 보았다. 하지만 임계 구역의 앞, 뒤로 항상 함수들을 사용해야 한다. 이는 프로그래머의 실수를 유발할 수 있어 항상 재현 가능하지는 않다. 이런 실수를 하지 않기 위한 간단한 방법은 동기화 도구를 통합하여 추상적 구조를 제공하는 것이다.  
모니터는 공유 데이터와 다른 변수들 그리고 이 데이터에 접근할 수 있는 함수로 구성되어 있다. 쉽게 말해 클래스라고 보면 된다. 모니터는 이 안에 항상 하나의 스레드만이 활성화되도록 보장해 준다.  

동기화를 하는 방법 몇 가지를 알아보았다. 하지만 이게 다가 아니다. 잘못 설계한다면 프로그램에 치명적인 영향을 주는 **교착 상태**(Deadlock)가 발생한다. 이 교착 상태가 왜 일어나는지, 어떻게 해결할 수 있을지 알아보자.  

## 교착 상태(Deadlock)  
여러 스레드가 한정된 자원을 가지고 경쟁을 하게 된다. 스레드 A와 B가 있다고 하자. 이때 A 스레드가 위의 동기화 기법에 의해 한 자원을 사용하길 원했지만 B 스레드가 사용하고 있어 대기 상태로 돌아갔다고 가정하자. 그런데 B 스레드는 또 다른 자원을 필요로 하는데 그 자원은 A가 점유하고 있다. A 스레드는 B 스레드가 점유하고 있는 자원을 원하고 B 스레드는 A 스레드가 점유하고 있는 자원을 원한다. 이렇게 되면 서로 상태를 **무한정 변경할 수 없게** 되는데 이것을 **교착 상태**라고 한다.  
교착 상태가 발생하기 위해서는 필요조건들이 있다. 이 필요조건들이 **모두 성립할 때** 교착 상태가 발생할 수 있다. 필요조건들은 아래와 같다.  
1. 상호 배제(mutual exclusion): 최소한 하나의 자원이 공유되지 않고 사용되어야 한다.
2. 점유하며 대기(hold-and-wait): 최소한 하나의 자원을 점유한 채 현재 다른 스레드에 의해 점유된 자원을 추가로 요청하며 대기하여야 한다.
3. 비선점(no preemption): 자원들을 선점할 수 없어야 한다. 점유하고 있는 스레드가 작업을 완료한 후 자발적으로 방출될 수만 있다.
4. 순환 대기(circular wait): 대기하고 있는 스레드의 집합은 순환적으로 점유한 자원들을 기다리고 있다.  

이러한 교착 상태를 어떻게 해결해야 할까. 교착 상태의 해결 방법에는 크게 세 가지가 있다.  
1. 교착 상태 예방  
교착 상태 예방은 위의 필요조건 4가지 중 **최소한 하나가 성립하지 않도록** 보장함으로써 교착 상태의 발생을 예방하는 것이다. 현실적인 접근 방식은 순환 대기를 제거하여 예방을 한다. 하지만 이런 예방 방법들은 **성능 저하**의 단점이 있다.  

2. 교착 상태 회피  
교착 상태 회피는 자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하여 각 요청에 대하여 교착 상태를 피하고자 스레드가 대기해야 하는지를 결정한다. 만약 스레드의 자원 요청에 의해서 ***안전***하다면 할당해 준다. 교착 상태 회피 알고리즘에는 대표적으로 **은행원 알고리즘**이 있다. 이 알고리즘은 교착 상태가 발생할 가능성이 있는 불안전 상태로 이끌 수 있는 자원 요청은 허가하지 않는다.  
`* 안전하다는 말은 요청하는 모든 자원을 할당해 줘도 교착 상태를 야기하지 않는다는 말이다. 물론 불안전하다고 해서 반드시 교착 상태로 간다는 것을 뜻하지는 않는다.`  

3. 교착 상태 탐지 후 복구  
탐지는 말 그대로 현재 실행 중인 스레드 및 자원을 검사하여 교착 상태에 있는지 아닌지 결정한다. 이후 교착 상태가 있다면 순환 대기 중인 스레드 하나를 중단하거나 교착 상태의 스레드의 자원을 선점하여 교착 상태에서 복구를 시도할 수 있다.  

## 요약
+ 동기화는 데이터의 일관성을 지키기 위해서 사용된다.  
+ 임계 구역은 경쟁 조건이 일어날 수 있는 코드 부분이다.
+ 뮤텍스 락은 임계 구역에 들어가기 전 lock을 획득하고 임계 구역에서 나올 때 lock을 반환한다.
+ 세마포는 뮤텍스 락과는 달리 정수 값을 가져 다양한 동기화 문제를 해결하는 데 사용될 수 있다.
+ 모니터는 동기화의 높은 수준의 형태를 제공하는 추상 데이터 유형이다.
+ 교착 상태는 두 개 이상의 스레드가 각자 원하는 자원을 점유하고 있어 무한정 대기하는 상황을 말한다.
+ 교착 상태에 필요한 네 가지 조건은 상호 배제, 점유하며 대기, 비선점, 순환 대기가 있다. 이 네 가지 조건을 모두 만족할 때 발생할 수 있다.

다음 파트에서는 cpu와 더불어 가장 중요한 하드웨어 자원인 **메모리를 어떻게 관리**하는지 알아볼 예정이다.  

`* 이 글은 소위 공룡 책이라고 하는 Operating System Concepts 책을 보고 정리한 글입니다. 제 생각대로 적다 보니 틀린 부분이 있을 수 있는데 지적해 주시면 감사하겠습니다.`